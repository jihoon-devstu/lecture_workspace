
--------------------------------------------------------------------------------------------------------

자바 수업 시작.

Maven Repository - mysql jdbc 검색 - 버전 클릭 - 아래 태그 복사

pom.xml 에 dependency 하나 추가

컨트롤 + 쉬프트 + F 로 들여쓰기 마무리
--------------------------------------------------------------------------------------------------------

JTable은 껍데기에 불과하므로 , 연동할 테이블이 수백개라 할지라도
TableModel은 1개면 충분하다... 결국 바뀌는건 쿼리문만 !! 

프레임에서 귀 달지 않고 , 별도의 클래스에서 리스너 구현해보기

익명 내부 클래스

bt_emp.addActionListener(new ActionListener(){
	public void actionPerformed(ActionEvent e) {
		System.out.println("눌렀어?");
	}	
});

--------------------------------------------------------------------------------------------------------

이벤트 구현 시 정의되는 리스너 클래스는 재사용성이 없으므로, 굳이  .java 파일까지 정의해가면서 개발할 필요가 있는가? 
내부클래스 중, 이름 없는 클래스를 가리켜 익명내부 클래스라 한다. 주로, 일회성 객체 사용시(이벤트)

익명 내부클래스는, 자신을 감싸고 있는 바깥쪽 외부 클래스의 멤버들을 
같이 사용할 수 있다..즉 접근할 수 있다는 점이 장점

--------------------------------------------------------------------------------------------------------

WindwoListener를 포함하여 , 이벤트 리스너 중 재정의할 메서드의 수가 너무 많은 경우
사용하지도 않는 부모의 메서드를 클래스 코드 안에 남겨놔야 하는 상황이 발생하게 됨 ! 

--------------------------------------------------------------------------------------------------------
KeyListener, WinbdowListener 등 재정의할 메서드가 3개 이상된느 인터페이스의 경우
개발자 대신 , 이미 java api 차원에서 , 즉 우리대신 리스터 인터페이스를
구현해 놓은 중간 객체들을 가리켜 어댑터라고 한다...

(마치 전자제품과 220볼트 사이의 완충 장치의 역할과 동일)

우리 대신 메서드들을 재정의해놓앗기 때문에 개발자는 구현의무가 없게됨 !! 

--------------------------------------------------------------------------------------------------------

JTable은 실제 데이터를 가진 주체가 아니고 , 단지 사용자들이 보게되는 UI (껍데기) 에 지나지 않기 때문에.
JTable에 보여질 데이터는 , 모델에 의존하게 됨.

이와 같이 디자인 (View) 영역과 데이터 및 그 처리 로직(Model) 을 분리 시켜 개발하는 방법을
MVC 패턴이라고 함.


--------------------------------------------------------------------------------------------------------
[창고관리] - 미니 프로젝트

1) 너무 현장의 자세하거나 특별한 업무는 자제. (보편적인 업무)

2) 창고 관리 업무 3 : 나머지 기술 7 (네트워크 , IO처리 , QR코드(혹은 바코드), 그래픽, 쇼핑몰)
			--> 6/13까지 수업하면 위 내용 다 수업 가능.

3) 규모 : 일주일

3) 프로젝트 진행 Summary

UI 기획서 = 6/16(월)까지 (완성도 높게) -> 6/12(목),13(금)까지 완성하고 조원끼리 검토.
ERD = 6/18(수)까지 테이블 구상
ERD 수정 = 6/19(목)까지 시간 잡고 진행.   
프로젝트 진행 시간 = 6/20(금)~6/27(금) 오후시간
프로젝트 발표 = 6/30

--------------------------------------------------------------------------------------------------------

내부클래스는 외부클래스의 인스턴스에 접근 시 , 클래스명.this 하면 됨.

--------------------------------------------------------------------------------------------------------

java 자체적인 api에는 엑셀을 연동하는 기능이 없기 때문에 , apache에서 배포하는 POI라는

패키지를 이용해 보자.

엑셀 파일(WorkBook) > WorkSheet(시트) > Row > cell

--------------------------------------------------------------------------------------------------------

Collection (집합,모음)

java에서 객체들을 모아서 처리할 때 유용한 방법을
지원해주는 api 집합을 가리켜 Collection Framework이라 함.
= 자료구조

[사물들이 모여진 모습 유형]

1. 순서 있는 모습 --> 중복을 허용함
	1-1 List (우리가 알고 있던 그 배열과 비슷함.)
	1-2 Queue(FIFO)

2. 순서 없는 모습 --> 중복을 허용하지 않음.
	2-1 Set (순서없이 막 들어있는 , 인덱스 번호가 없는 모습)
	2-2 Map (Key 와 Value가 있음.) <key-value>


--------------------------------------------------------------------------------------------------------

자바의 컬렉션 프레임웍은 java.util 패키지에서 지원하며
그 중,  순서있는 집합을 처리하는데 대표적인 List에 대해 알아본다.

List vs 배열

공통점 - 순서를 가지며 인덱스로 접근 가능.

차이점 - 배열은 생성 시 , 반드시 크기를 명시해야 함, 기본 자료형도 담을 수 있음.
	컬렉션(List)의 대상은 오직 객체만을 대상으로 함. -> JS의 배열과 같음

컬렉션 프레임웍은 , 최상위 이너페이스들의 메서드를 주로 사용하기 때문에 , 
하위의 어떠한 구현객체를 사용하더라도 메서드 사용이 일관성이 있다.

담을때는 거의 add, 길이는 거의 size() 


--------------------------------------------------------------------------------------------------------

<자료형> 을 명시하면 , 컴파일러가 다른 자료형을 거부한다....

즉 컴파일 타임에 자료형 체크를 해줌. (제너릭 Generic) 타입이라 한다.

java7부터는 다이아몬드 연산자 도입.

<String> 앞에서 명시 했으면 , 뒤에선 <>만 적어놓아도 스스로 추정하므로 , 자료형 생략 가능.

Ex. Set<String> set = new HashSet<>(); 
--------------------------------------------------------------------------------------------------------
(순서 있는 유형 1)
- List - 

List<String> list = new ArrayList(); //고무줄 배열 (JS랑 동일)
		
		list.add("apple");
		list.add("banana");
		list.add("grape");
		list.add("orange");
		
		for(int i=0;i<list.size();i++) {
			System.out.println(list.get(i));
		}
		
		for(Object obj : list) {
			System.out.println(obj);

--------------------------------------------------------------------------------------------------------
(순서 없는 유형 1)
- Set -

순서 없는 Set은 크기는 알 수 있지만 , 직접적으로 for문을 돌릴순 없다 .
따라서 풀어놓고 늘어뜨려야함.

	Set<String> set = new HashSet<>(); //앞에<String>을 적으면 , 뒤에<>에는 자료형 적을 필요 없음 !  
		
	set.add("BMW");
	set.add("Benz");
	set.add("Audi");
	set.add("K9");
		
	Iterator<String> it = set.iterator();
		
	while(it.hasNext()) {
		String obj = it.next();
		System.out.println(obj);
	}


--------------------------------------------------------------------------------------------------------
(순서 없는 유형 2)

 - map - 

	Map <String, String>map = new HashMap();
		
	map.put("a1", "가나초콜릿");
	map.put("a2", "허쉬초콜릿");
	map.put("a3", "페레로로쉐");
		
	Set set = map.keySet();
	Iterator<String> it = set.iterator();
		
		
	while(it.hasNext()) {
		String key = it.next();
		String value = map.get(key); //기존 맵에서 Key 이용하여 접근
			
		System.out.println(key +","+value);
	}

--------------------------------------------------------------------------------------------------------

자바의 모든 컴포넌트는 스스로를 그린다 . 하지만 개발자가 그림을 뺏어도 되는 컴포넌트는
주로 , 내용이 비어있는 컨테이너 유형이다.
JPanel , Canvas 등등...




--------------------------------------------------------------------------------------------------------






--------------------------------------------------------------------------------------------------------






	
--------------------------------------------------------------------------------------------------------







--------------------------------------------------------------------------------------------------------





--------------------------------------------------------------------------------------------------------





--------------------------------------------------------------------------------------------------------




--------------------------------------------------------------------------------------------------------

